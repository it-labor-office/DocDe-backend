# ⭐ 프로젝트 개요 

## 🧾 **프로젝트 명**

### 프로젝트명

## 🪕 **프로잭트 소개**

### 프로젝트 소개

---

⭐ **주요 기술 스택**

![인텔리제이](https://img.shields.io/badge/IntelliJ_IDEA-000000.svg?style=for-the-badge&logo=intellij-idea&logoColor=white)
![깃허브](https://img.shields.io/badge/GitHub-100000?style=for-the-badge&logo=github&logoColor=white)

***Development***
    
![Redis](https://img.shields.io/badge/Redis-DC382D?style=for-the-badge&logo=redis&logoColor=white)
![자바](https://img.shields.io/badge/Java-ED8B00?style=for-the-badge&logo=openjdk&logoColor=white)
![스프링](https://img.shields.io/badge/Spring-6DB33F?style=for-the-badge&logo=spring&logoColor=white)
![스프링부트](https://img.shields.io/badge/Spring-6DB33F?style=for-the-badge&logo=springboot&logoColor=white)
![mysql](https://img.shields.io/badge/MySQL-00000F?style=for-the-badge&logo=mysql&logoColor=white) <p>
***Communication***

![슬랙](https://img.shields.io/badge/Slack-4A154B?style=for-the-badge&logo=slack&logoColor=white)
![노션](https://img.shields.io/badge/Notion-000000?style=for-the-badge&logo=notion&logoColor=white)

---

#### ERD :

---

## 프로젝트 핵심 목표

1. **대규모 트래픽 대응**
   - Redis와 Kafka를 활용한 비동기 처리를 통해 API 요청 200req/sec 이상 처리.
   - 동시성 문제를 해결하며 안정적인 쿠폰 발급 서비스 제공.

2. **성능 최적화**
   - Redis 기반 캐싱으로 실시간 상품 조회 성능을 3배 향상.
   - Redisson을 사용하여 CPU 점유율 50% 감소 및 안정적 데이터 처리 구현.

3. **운영 및 배포 효율화**
   - Docker와 Github Actions를 이용한 CI/CD 파이프라인 구축으로 배포 자동화.
   - Prometheus와 Grafana를 활용한 실시간 모니터링으로 시스템 안정성 확보.

4. **데이터 일관성 및 트랜잭션 관리**
   - Kafka를 이용한 SAGA 패턴으로 분산 트랜잭션 관리.
   - 중복 및 데이터 손실을 방지하는 Kafka Batch Listener 구현.

## KEY Summary

### 🍁 **성능 개선 : 최저가 상품 조회 성능, Redis 도입으로 3배 이상 향상**

1. **한 줄 요약**  
   - Redis 도입으로 기존 DB 조회보다 **348% 성능 개선**  
   - 대규모 트래픽 환경에서도 안정적인 서비스 유지  

   ![성능 개선 이미지]

2. **도입 배경**  
   - 상품의 최저가를 제공하기 위해 외부 서버에서 제공하는 타임세일 상품의 할인율과  
     상품 자체의 할인율을 비교하는 기능이 필요  

3. **기술적 선택지**  

   1. **DB 데이터 적재**  
      - 스케줄링 작업으로 짧은 시간 내 대량의 데이터를 수정하는 것은 데이터베이스에 과도한 부하 발생  
      - 상품 자체의 할인율과 타임세일 할인율을 분리하여 별도 컬럼 저장 필요  

   2. **Redis 캐싱**  
      - 실시간 최저가 할인율로 최신 정보와 가격 제공  
      - TTL 설정으로 타임세일 종료 시 자동 데이터 삭제  

   **결론:** Redis 도입을 결정하여 성능 및 효율성을 크게 개선  

---

### 🍁 **트러블 슈팅 : LazyConnectionDataSourceProxy - 불필요한 커넥션 점유 해결**

1. **배경**  
   - **스프링 배치 5버전 도입**  
     - 정산은 실시간이 아닌, 이용자가 적은 시간에 일괄 처리하도록 배치 선택  
     - 메인 DB와 배치 메타데이터 DB 분리 필요  
   - **배치 메타데이터 테이블 생성 필수화**  
     - 메타데이터 전용 DB를 나누는 구조로 전환  
   - **멀티 DataSource 구성**  
     - 메인 DataSource와 배치 DataSource로 데이터베이스 모듈 구분  

2. **문제**  
   - 실제 DB 요청 없이도 불필요한 커넥션 점유 발생  
     - 스프링은 트랜잭션 진입 시 커넥션 풀에서 커넥션을 점유  
     - 멀티 DataSource로 인해 두 DataSource 모두 커넥션 점유  

3. **해결 방안**  
   - **LazyConnectionDataSourceProxy 클래스 사용**  
     - 실제 DB 요청 전까지 커넥션 점유를 지연시키는 프록시 DataSource 활용  

   ![LazyConnectionDataSourceProxy 이미지]

   - 이를 통해 **실제 DB 요청 시에만 커넥션 점유**로 불필요한 리소스 낭비를 해결

## 인프라 아키텍처 & 적용 기술

### 아키텍처 다이어그램
![Infra Architecture]

위 아키텍처는 **MSA 기반의 이커머스 서비스** 구조를 나타냅니다.  
각 모듈은 Redis, Kafka를 통해 통신하며, Docker로 컨테이너화되어 CI/CD를 통해 자동 배포됩니다.

---

<details>
<summary><b>📦 적용 기술 상세보기</b></summary>

### 💾 **데이터베이스 및 캐싱**
1. **Redis**  
   - **적용 위치**: 캐시 서버  
   - **사용 이유**: 실시간 상품 할인율과 최저가 조회 성능 향상. TTL 설정으로 타임세일 종료 시 데이터 자동 삭제.  

---

### 📬 **메시징 시스템**
1. **Apache Kafka**  
   - **적용 위치**: 서비스 간 비동기 통신  
   - **사용 이유**: 대규모 메시지 처리를 위한 안정적 메시징 큐 구현.  
   - **구체적 역할**: 주문 생성 시 재고 차감, 쿠폰 적용 등 서비스 간 데이터 일관성 보장.  

---

### 🌐 **인프라 및 배포**
1. **Docker**  
   - **적용 위치**: 모든 서비스 컨테이너화  
   - **사용 이유**: 환경 이식성과 배포 속도 개선.  

2. **Github Actions**  
   - **적용 위치**: CI/CD 파이프라인  
   - **사용 이유**: 자동화된 코드 품질 검사와 배포 구현.  

3. **Prometheus & Grafana**  
   - **적용 위치**: 실시간 모니터링  
   - **사용 이유**: 주요 메트릭(트래픽, CPU 사용량 등) 수집 및 시각화로 장애 발생 시 빠른 대응 가능.  

</details>

## 주요 기능

### 🍁 **쿠폰 발급: Redis 및 Kafka를 통한 비동기 처리**
- 대용량 트래픽을 수용하기 위해 Redis와 Kafka를 활용한 비동기 쿠폰 발급 시스템 구현.
- Redis Lua Script로 동시성 제어 및 쿠폰 발급 상태 관리.

---

### 🍁 **주문 처리: Saga 패턴 적용**
- 각 서비스 간 독립적 트랜잭션 관리를 위해 Saga(Choreography) 패턴 적용.  
  - **주요 흐름**: `상품 재고확인 & 차감` → `쿠폰 사용 확인 & 상태 변경` → `적립금 사용 확인 & 차감`.  
- 오류 발생 시 자동 롤백을 통해 데이터 일관성 유지.

---

### 🍁 **최저가 조회: Redis 캐싱 활용**
- Redis 캐싱을 이용해 상품의 실시간 최저가 제공.  
- 짧은 TTI와 TTL 설정으로 리소스 절약 및 캐싱 효율성 극대화.

---

### 🍁 **결제 정산: Spring Batch 5 활용**
- 대규모 결제 데이터를 특정 시간에 자동으로 처리하는 배치 시스템 구축.  
  - **프로세스 흐름**: `결제 완료 데이터 조회` → `수수료 차감` → `정산 결과 저장`.  
- 배치 처리로 대규모 트랜잭션 최적화.
## 기술적 고도화

<details>
<summary><b>🍁 분산락 Redisson 도입으로 CPU 점유율 2배 개선</b></summary>

### 왜 동시성 제어 시 여러 선택지가 있는데, 분산락을 사용했을까요?

---

#### 낙관적 락과 비관적 락의 선택지

분산락을 채택하기 이전에는 비관적 락으로 동시성 제어를 선택했습니다.

- **비관적 락**  
  비관적 락으로 데이터를 조회하면 해당 트랜잭션이 끝나기 전까지는 데이터에 대한 Insert 작업이 불가능합니다.  
  - 단점: 트래픽이 많은 경우 성능 저하 발생 및 타임아웃 문제.  

- **낙관적 락**  
  낙관적 락은 충돌 발생 시 롤백 처리를 요구하며, 충돌 비용이 높습니다.  
  - 단점: CPU 점유율이 상승하고, 예상치 못한 오류 발생 가능.  

---

#### Redis로 분산락을 채택한 이유

1. **Lettuce의 문제점**  
   Lettuce는 스핀락 방식을 사용하여 락이 풀릴 때까지 계속 Redis에 요청을 보냅니다.  
   - 결과적으로 Redis CPU 점유율이 높아지는 문제가 발생.

2. **Redisson의 장점**  
   Redisson은 Pub-Sub 구조로 락이 종료될 때 이벤트를 발행하며, 락 요청을 효율적으로 처리합니다.  
   - 결과적으로 Redis CPU 점유율이 낮아집니다.  

---

### 적용 후

- **CPU 점유율:** 기존 60% → 30% 감소  
- **TPS:** 기존 1400 → 2500으로 향상  

</details>

---

<details>
<summary><b>🍁 Jpa로 배치 처리 시 더티체킹 문제</b></summary>

### 배경

- `JpaItemReader` 채택  
  - `스프링 배치`에서 제공하는 `ItemReader` 인터페이스로 데이터를 조회하는 구현체입니다.  
  - Jpa 엔티티의 메서드를 사용하기 위해 `JpaItemReader`를 선택했습니다.

---

### 문제

- **더티체킹으로 인한 성능 문제**  
  - 예상보다 더 많은 쿼리가 발생했습니다.  
  - 5만 건을 500개씩 배치 처리할 경우, 100개의 쿼리가 아닌 `100 + 5만`건의 쿼리가 추가 발생.  
  - 데이터 처리 시간: **4분 46초**

---

### 해결

- **JdbcPagingItemReader로 변경**  
  - 더티체킹 문제를 제거하며 추가적인 쿼리 발생을 방지했습니다.  
  - 결과적으로 데이터 처리 시간이 기존 4분 46초에서 **60초로 4.6배 개선**되었습니다.  

---

### 향후 계획

- **Java 21의 가상 스레드 활용**  
  - `TaskExecutor`를 재구성하여 병렬 처리 효율성을 극대화할 예정입니다.

</details>

## 역할 분담 및 협업 방식

### **Detail Role**

| 이름   | 포지션   | 담당(개인별 기여점)                                                                                                            | Github 링크                       |
|--------|----------|-----------------------------------------------------------------------------------------------------------------------------|-----------------------------------|
| 김ㅇㅇ | 리더     | ▶ **결제**: 토스페이먼츠 PG 연동, 간편결제 구현<br>▶ **정산**: 스프링 배치 활용 (Jpa → Jdbc 변경하여 4.6배 개선)<br>▶ **배포**: 멀티모듈 설정, 멀티 데이터소스 설정, Graceful Shutdown 구현, CI/CD 적용 | [🍁 깃헙링크] |
| 조ㅇㅇ | 부리더   | ▶ **쿠폰**: Redis Lua Script를 통한 동시성 제어 및 대규모 트래픽 제어<br>▶ **타임세일**: Kafka 비동기 발급 처리, 분산락을 통한 동시성 제어                          | [🍁 깃헙링크]    |
| 박ㅇㅇ | 팀원     | ▶ **주문**: MSA 기반 주문 로직 구현, Kafka 기반 SAGA 패턴 적용<br>▶ **스케줄러**: 결제 단계 주문 자동 삭제                                                | [🍁 깃헙링크]     |
| 정ㅇㅇ | 팀원     | ▶ **유레카 & 게이트웨이**: CircuitBreaker, Retry 장애 대응 구축<br>▶ **유저**: Kafka Batch Listener를 활용한 대용량 데이터 적재<br>▶ **상품**: Redis 최저가 조회 성능 개선, Kafka 비동기 통신 구현 | [🍁 깃헙링크]    |

---

### **Ground Rule**

🍁 **문제 발생 시 즉시 공유**  
- 문제가 발생하면 팀원들에게 빠르게 상황을 공유하여 협력 해결.

🍁 **정규 시간 내 풀타임 화면 공유**  
- 업무 시간 동안 항상 화면을 공유하여 투명한 협업 유지.

🍁 **사소한 것도 질문하기**  
- 궁금한 점이나 막힌 부분은 사소한 것이라도 즉시 물어보고 해결.

🍁 **스크럼에서 트러블 슈팅 및 구현 사항 설명**  
- 매일 스크럼 시간에 구현 진행 상황과 문제 해결 과정을 공유.

🍁 **1Day, 1Issue, 1PR 원칙**  
- 하루에 하나의 이슈를 처리하고 PR 생성.

🍁 **1PR 당 3개 이상의 리뷰 남기기**  
- 각 PR에 대해 최소 3개의 리뷰를 작성하여 코드 품질을 개선.
## 성과 및 회고

### 잘된 점
- **성능 최적화 성공**  
  - Redis와 Kafka를 도입해 대규모 트래픽 환경에서도 안정적인 쿠폰 발급 구현.  
  - API 처리량 250req/sec를 초과 달성하며 목표를 상회하는 성과를 기록.  

- **효율적인 협업**  
  - 팀원 간 역할 분담이 명확했으며, GitHub Actions를 활용한 CI/CD 구축으로 개발-배포 주기를 단축.  
  - 매일 스크럼을 통해 문제를 빠르게 공유하고, 적극적으로 해결.  

---

### 아쉬운 점
- **프로젝트 초기 설계 부족**  
  - 도메인 설계 및 서비스 분리 단계에서 충분한 검토가 이루어지지 않아 일부 마이크로서비스 간 의존성 증가.  

- **시간 부족으로 일부 기능 미완성**  
  - 사용자 피드백 시스템과 추가 정산 기능 개발이 지연되어 구현하지 못함.  

---

### 향후 계획
- **기술적 고도화**  
  - Java 21의 가상 스레드를 도입하여 병렬 처리 성능을 개선하고, 무중단 배포를 위한 추가적인 CI/CD 개선 계획.  

- **추가 기능 개발**  
  - 사용자 피드백 시스템 도입으로 서비스 품질을 지속적으로 향상.  
  - 데이터 분석 기능을 추가해 쿠폰 발급 및 사용 데이터를 기반으로 한 비즈니스 인사이트 제공.  

- **테스트 자동화 강화**  
  - 기존 단위 테스트 외에 통합 테스트 및 부하 테스트를 추가하여 안정성을 더욱 강화.








